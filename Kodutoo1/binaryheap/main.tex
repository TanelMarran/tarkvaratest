\documentclass[11pt]{article}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage[none]{hyphenat}
%\usepackage{times}
\usepackage{parskip}
\linespread{1.25}
%\overfullrule=1cm
\usepackage[left=4cm,top=3cm,right=2cm,bottom=3cm]{geometry}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{fancyhdr}
\pagenumbering{gobble}
%\documentclass[tikz, border=5pt, multi, varwidth]{standalone}
\usepackage{forest}
%\standaloneenv{forest}
\usepackage{grffile}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{minted}
\newminted{java}


\begin{document}
\pagestyle{fancy}
\rhead{Kaarel Kaasla (Group 1)}
%\maketitle

\section*{Software Testing Homework 1: Debugging}

\subsection*{1. Max binary heap}
\newline
\textbf{Issue 1} - The program should heapify any given list of positive integers but the resulting tree (and list) does not meet the max binary heap structure.
\newline
Input: [1, 2, 5, 7, 6, 8, 11, 10, 3, 4, 9, 1, 0]
\newline
Expected output: [11, 10, 8, 7, 9, 1, 5, 2, 3, 4, 6, 1, 0]
\newline
Actual output: [11, 9, 5, 3, 9, 7, 1, 6, 3, 4, 2, 1, 0]

\hfill\begin{minipage}{\dimexpr\textwidth-0.5cm}
\textbf{Bug 1}
\newline
The first bug is on the second and third line of \verb/leftChildIndex/ method:
\begin{javacode}
    private int leftChildIndex(int index) {
        if (valueList.size() > (2 * index) - 1) {
            return (2 * (index) - 1);
        } else return -1;
    }
\end{javacode}
If we have a binary heap structure, the index of the left child of an element can be found by $(2 \cdot \verb/index/) + 1$ where \verb/index/ refers to the parent element's position. Therefore, the correct method would be:
\begin{javacode}
    private int leftChildIndex(int index) {
        if (valueList.size() > (2 * index) + 1) {
            return (2 * (index) + 1);
        } else return -1;
    }
\end{javacode}
\end{minipage}

\hfill\begin{minipage}{\dimexpr\textwidth-0.5cm}
\textbf{Bug 2}
\newline
Another bug is on the third line in the following section of the \verb/BubbleDown/ method:
\begin{javacode}
    if (currentElem < leftChild) {
        if (leftChild > rightChild) {
            valueList.set(index, rightChild);
            valueList.set(leftChildIndex, currentElem);
            BubbleDown(leftChildIndex);
        } else {
            valueList.set(index, rightChild);
            valueList.set(rightChildIndex, currentElem);
        }
    }
\end{javacode}
The third and fourth line should swap \verb/currentElem/ and \verb/leftChild/, but instead change \verb/currentElem/ to \verb/rightChild/ and \verb/leftChild/ to \verb/currentElem/. For this reason, the if-block of the method should be:
\begin{javacode}
    if (leftChild > rightChild) {
        valueList.set(index, leftChild);
        valueList.set(leftChildIndex, currentElem);
        BubbleDown(leftChildIndex);
    }
\end{javacode}
\end{minipage}

\hfill\begin{minipage}{\dimexpr\textwidth-0.5cm}
\textbf{Bug 3}
\newline
Third bug is also in the \verb/BubbleDown/ method, but in the else-block of the above code shown regarding the second bug:
\begin{javacode}
    else {
        valueList.set(index, rightChild);
        valueList.set(rightChildIndex, currentElem);
    }
\end{javacode}
Even though the swap is done correctly, this part of the method is missing a \verb/BubbleDown/ method call, since it's possible that we might need to bring an element down more than one level (currently does exactly one swap). For this reason, the correct code would be:
\begin{javacode}
    else {
        valueList.set(index, rightChild);
        valueList.set(rightChildIndex, currentElem);
        BubbleDown(rightChildIndex);
    }
\end{javacode}
\end{minipage}


\textbf{Issue 2} - When adding elements to a heap, the element should automatically go to the correct location in the heap. However, after adding elements, the resulting list (tree) does not match the expected max bin heap structure, there are different elements than what should be there (some more, some missing).
\newline
Input: [1, 2, 5, 7, 6, 8, 11, 10, 3, 4, 9, 1, 0], then add integers 13 and 4
\newline
Expected output: [13, 10, 11, 7, 9, 1, 8, 2, 3, 4, 6, 1, 0, 5, 4]
\newline
Actual output: [11, 13, 5, 13, 9, 7, 13, 6, 3, 4, 2, 1, 0, 13, 4]

\hfill\begin{minipage}{\dimexpr\textwidth-0.5cm}
\textbf{Bug 4}
\newline
There is a bug in the \verb/BubbleUp/ method:
\begin{javacode}
    if (currentElem > parent) {
        valueList.set(parent, index);
        valueList.set(parentIndex, currentElem);
        BubbleUp(parentIndex);
        }
\end{javacode}
What happens there is that the \verb/set/ method should take \verb/index/ and \verb/parent/ as arguments in that order, but in the present case, the order is switched so the method inserts the \verb/index/ at the position that corresponds to the value of the \verb/parent/. For this reason, the correct order should be as outlined below:
\begin{javacode}
    if (currentElem > parent) {
        valueList.set(index, parent);
        valueList.set(parentIndex, currentElem);
        BubbleUp(parentIndex);
    }
\end{javacode}
\end{minipage}

\hfill\begin{minipage}{\dimexpr\textwidth-0.5cm}
\textbf{Bug 5}
\newline
There is also a bug in the \verb/elemParentIndex/ method:
\begin{javacode}
    private int elemParentIndex(int index) {
        if (index > 0) {
            return index / 2;
        } else return -1;
    }
\end{javacode}
The method can return an incorrect value, since an element's parent index should be calculated $\lfloor (\verb/index/ - 1) / 2 \rfloor$. Therefore, the correct version would be (flooring is not required since Java already rounds towards zero):
\begin{javacode}
    private int elemParentIndex(int index) {
        if (index > 0) {
            return (index - 1) / 2;
        } else return -1;
    }
\end{javacode}
\end{minipage}

\textbf{Issue 3} - When removing a given element (the first occurrence of that element) the element should be gone, the rest of the heap in a correctly sorted order, and the list itself one element shorter. The element is gone, but the heap is not in the correct order and the size of the list is not smaller.
\newline
Input: [1, 2, 5, 7, 6, 8, 11, 10, 3, 4, 9, 1, 0], add elements 13 and 4, then remove element 10 and try to remove non-existing element 99.
\newline
Expected output: [13, 9, 11, 7, 6, 1, 8, 2, 3, 4, 4, 1, 0, 5]
\newline
Actual output: [11, 13, 5, 13, 9, 7, 13, 6, 3, 4, 2, 1, 0, 13, 4]

\hfill\begin{minipage}{\dimexpr\textwidth-0.5cm}
\textbf{Bug 6}
\newline
The last bug is in the following section of the \verb/removeElem/ method:
\begin{javacode}
    valueList.remove(valueList.size() - 1);
    valueList.set(indexOfRemoveElem, lastElem);
    int parentOfRemoved = elemParent(indexOfRemoveElem);
    if (lastElem < parentOfRemoved) {
        BubbleUp(indexOfRemoveElem);
    } else if (lastElem > parentOfRemoved) {
        BubbleDown(indexOfRemoveElem);
    }
\end{javacode}
Restructuring of the heap is done incorrectly in the above method. The method states that if \verb/lastElem/ is smaller than \verb/parentOfRemoved/, \verb/BubbleUp/ is be called on it and similarly, if \verb/lastElem/ is larger, \verb/BubbleDown/ is called. For the restructuring to work correctly, the logic should be implemented in reverse; calling \verb/BubbleDown/ when the element is smaller since it might also be smaller than its children and calling \verb/BubbleUp/ when it's larger. Thus, the corrected version of this part would be:
\begin{javacode}
    valueList.remove(valueList.size() - 1);
    valueList.set(indexOfRemoveElem, lastElem);
    int parentOfRemoved = elemParent(indexOfRemoveElem);
    if (lastElem < parentOfRemoved) {
        BubbleDown(indexOfRemoveElem);
    } else if (lastElem > parentOfRemoved) {
        BubbleUp(indexOfRemoveElem);
    }
\end{javacode}
\end{minipage}

\subsection*{2. Genetic	algorithm}
\end{document}
